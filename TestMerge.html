<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>title</title>
 
  <script src="../three.js/build/three.js"></script>
  <script src="../three.js/examples/js/controls/OrbitControls.js"></script>
  <script src="../three.js/examples/js/libs/dat.gui.min.js"></script>
  <script src="../three.js/examples/js/libs/stats.min.js"></script>
  <script src="../three.js/examples/js/utils/BufferGeometryUtils.js"></script>
</head>

<body onload="draw()">
  <script>
    let scene,stats,camera;
    var controls;
    let renderer;
    var mergeMesh,mergeGeometry;
    var geometries = [];//存放需要合并的geometry

    var width = window.innerWidth; //窗口宽度
    var height = window.innerHeight; //窗口高度

    // draw();

    /*绘制函数*/
    function draw(){
        var LastTime = Date.now();
        init();
        var now = Date.now();
        var elapsed = now - LastTime;
        console.log(elapsed);
        animate();
        window.onresize = onWindowResize;
    }

    /*初始化方法*/
    function init(){
        initRender();
        initScene();
        initCamera();
        initLight();
        initModel();
        mergeCube(198);//测试顶点数
        initControls();
        initStats();
    }

    function initScene(){
        scene = new THREE.Scene();
    }
   
    /*合并geometry*/
    function mergeCube(count){
        /*生成8000个geometry 放进geometries数组中*/
        for(var i=0; i<8000; i++){
            var cube = RandomCube(count);
            if(cube){
                geometries.push(cube);
            }
        }
        var mergeGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(geometries);
        mergeMesh = new THREE.Mesh(mergeGeometry,material);
        scene.add(mergeMesh);
    }

    var material = new THREE.MeshLambertMaterial({
        color: 0x00ff00, transparent: true, opacity: 0.8,side:THREE.DoubleSide
    });

    /*生成不同位置大小cube*/
    function RandomCube(count){
        var cubeSize = 1.0;
        // var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
        // const cylinderGeometry = new THREE.CylinderGeometry( 5, 5, 10, 32 );
        const circleGeometry = new THREE.CircleGeometry( 1, count );
         let transform = new THREE.Object3D();

        transform.position.set(-100+Math.random() * 200, -100+Math.random() * 200, -100+Math.random() * 200);
        transform.scale.set(Math.random(), Math.random(), Math.random());
        transform.rotateX(Math.random()*360);
        transform.rotateY(Math.random()*360);
        transform.rotateZ(Math.random()*360);
        transform.updateMatrix();

        // cubeGeometry.applyMatrix4(transform.matrix);
        // return cubeGeometry;

        circleGeometry.applyMatrix4(transform.matrix);
        return circleGeometry;
    }

    // /*自定义顶点BufferGeometry*/
    // function addBufferGeometry(){
    //     const geometry = new THREE.BufferGeometry();
    //     // create a simple square shape. We duplicate the top left and bottom right
    //     // vertices because each vertex needs to appear once per triangle.
    //     const vertices = new Float32Array( [
    //         -1.0, -1.0,  1.0,
    //         1.0, -1.0,  1.0,
    //         1.0,  1.0,  1.0,

    //         1.0,  1.0,  1.0,
    //         -1.0,  1.0,  1.0,
    //         -1.0, -1.0,  1.0
    //     ] );

    //     // itemSize = 3 because there are 3 values (components) per vertex
    //     geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
    //     const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
    //     const mesh = new THREE.Mesh( geometry, material );
    //     scene.add(mesh);
    // }
    
    function initModel(){
        var helper = new THREE.AxesHelper(50);
        scene.add(helper);
    }
    
    function initStats() {
        stats = new Stats();
        document.body.appendChild(stats.dom);
    }


    function initLight(){
        var point = new THREE.PointLight(0xffffff);
        point.position.set(400, 200, 300); 
        scene.add(point); 
        var ambient = new THREE.AmbientLight(0x444444);
        scene.add(ambient);
    }
  
    /*初始相机*/
     function initCamera(){
        var aspect = width / height; //窗口宽高比
    
        camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
        camera.position.set(0, 40, 100);
        camera.lookAt(new THREE.Vector3(0,0,0));

     }
  
    /*初始化渲染器*/
    function initRender(){
        renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(width, height); 
        renderer.setClearColor(0x000000, 1); 
        document.body.appendChild(renderer.domElement); 
    }
    

    // 渲染函数
    function render() {
      renderer.render(scene, camera); //执行渲染操作
    }

    /* 更新*/
    function animate(){
        stats.begin();
        render();
        stats.end();
       // stats.update();//更新性能插件
        controls.update();
        stats.end();
        requestAnimationFrame(animate);
    }

    //窗口变动触发的函数
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        render();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }

    /*初始化控制*/
    function initControls(){
        controls = new THREE.OrbitControls( camera,renderer.domElement );
        controls.enableDamping = true;
        controls.enableZoom = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.minDistance  = 10;
        controls.maxDistance  = 500;
        controls.enablePan = true;
        
    }
    
  </script>
</body>

</html>
